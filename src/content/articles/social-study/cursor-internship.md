---
title: "社會課｜交友軟體開發小感"
date: "2025-06-04"
tags: ["社會課"]
isPinned: false
excerpt: "做了一個自己理想中的交友軟體，即便我沒用過呵呵"
---

### 由 Project 學習，同時思考社會

> 大部分人好像都沒辦法理性的表達並挑選適合自己的人，對吧。

最近很認真的為了充實自己而又開始做規模比較大的 side project，認真（不敢說深，只能說是勇敢）地去鑽研 concurrency、CORS、rate limit、DB 選型之類我以前一直懶得探討的議題。

身為一個從來沒用過交友軟體的人，我甚至連女巫機制都想了一下（超級懶的去搞什麼證件驗證，我相信用戶也是吧），最後還是只能用陽春的手機 OTP。

本來想要用社群媒體發文附帶驗證碼兼推薦碼兼配對碼的形式（有點像遠古時期領水龍頭要發推文那樣），來過濾免洗帳號還有低社交價值的帳號（爬一下 threads followers & repost 之類的）。

也想過 ClubHouse 那樣純推薦的形式，總而言之不是透過 API 或爬蟲去抓社交媒體帳號，就是人與人的連結，利用社交網來驗證一個人到底是真的還假的。

重點不是過濾的成效如何（因為我不在乎），我想追求的還是一個「基本過濾 + 宣傳效果」。然而大部分朋友都跟我說用交友軟體的人不會想讓身邊的人知道自己在用，所以這個社群機制最後移到獎勵任務而不是註冊必要環節。

另外一個遇到的問題是 business model，身為一個不知道怎麼賺別人錢的人，除了廣告版面還有儲值降低限制這兩招之外，還真的想不到其他招了。這個之後再說反正高機率這只是我練功的 project 不會進到 EA 甚至 public beta。

做這個 project 還是蠻有趣的，因為我根本沒用過，只是大概聽大家抱怨現行交友軟體們有遇到什麼問題，然後練過一些以交友軟體為底的系統設計/ DSA 面試題而已。所以說不定最後能寫出一個超級跳脫框架思維的軟體，也可能寫出一個狗都不想用的體驗超差的軟體。

最後，我目前設計的交友軟體配對機制真的蠻讚的啦！我自己感覺很能夠過濾怪人找到自己想要的人，至少如果是我的話完全不想只靠自介跟頭貼左右滑。

等實作完開放 private beta 再給親友們優先試用給 review。

### Cursor 工讀生小感

> 我們不太會被 Stackoverflow 上的白癡騙，是因為他會有很多倒讚，而且他永遠都在，跟紀念碑一樣

這兩個禮拜用工讀生 Cursor 加速了很多機械化的工作，也解決了一些一直以來覺得麻煩的問題（例如前端切版、視覺設計、單元測試）。感想還是在系統設計、資料結構與演算法、效能上要有正確的認知，才能夠寫出好的程式碼。

網路上很多人分享的 AI 寫程式用法大部分都是侷限在小工具還有 one click / no code / vibe coding 上，這種抽卡式的寫法不僅無法應對規模稍大的專案，也會讓可維護性變得極低，畢竟再怎麼整合總是有極限（token 有限）。

最難的就是一些規格式的調整還有細部的微調，這種非機械化的工作，是需要多方配合、來回應對、思考選型、來龍去脈的工作。一直以來，直到今天，我都是這麼認為的，因為版本調控、歷史脈絡、人與人、人與機器之間造成的隔閡永遠無法消除。

AI 時代或許人們的價值主要就在這吧，終究要有人來修 bug，終究要有人對結果負責，終究要有個人去了解為什麼現在是這樣而不是那樣，終究要有人去踩坑然後優化模型。

所以就會強迫每個人都要有 senior 的思考模式與知識背景。

我不認為在此時此刻變成 senior 是很困難的事情，因為有 AI 的幫助你更可能無緣無故生出自己寫不出來的程式碼，這時候如果勤勞一點問一下 AI 甚至實際找 senior 問一下，就能得到非常多收穫，加速學習效率。

但如果生出程式碼之後只是無腦 accept all，就是落後整個時代一大截。其實從 PD, PBC 開始學程式就是該這樣，得 code trace，得了解為什麼這裡是這樣而不是那樣，掌握 tips 和 theory，才有辦法解決複合式的難題。

過往我們的學習真的很沒效率，因為不會的東西很難去聯想說他該長什麼樣，很難去思考部件跟部件之間如何運作，很難在網路上找到真正可用的知識或實作範例。

大家常常有一個的思考盲點，就是結果才是唯一重要的，但其實並不是，過程才是。因為人生會面對到的所有問題都會一而再再而三發生，這次能夠抽中 SSR，不代表下一次可以。

我後來才知道大家解決問題的方式跟我完完全全不一樣，我在寫文章、研究新東西、解決 bug 的時候，通常都會 Google 然後把所有可能的分頁全部打開，再一個一個 resolve 掉，有的時候一個簡單的指令能夠達成的目的，我可能還是會開幾十個分頁。

但大部分人都只會開前三個，這種伸手牌式的搜尋法，才會覺得大型語言模型能夠取代搜尋引擎。

而且我們遇到的問題很多時候不是單一問題，例如不是一個 feature 怎麼做出來，也不是一個專案怎麼做出來，而是效能不夠怎麼辦、成本不夠怎辦、老闆喜歡這個做法怎麼辦、監管機構要這個規範怎麼辦。

所以本質上解決問題不是為了獲得一個唯一解，而是去了解問題從何而來、誰用了什麼方法嘗試解決、誰與誰爭執、誰提出的解法獲得廣大工程師同胞的稱讚或批評。

所以最後工程師的工作可以被歸類在吵架上，也就是我們都能夠讓這些人工智慧成為我們的工讀生去做一些機械化的事情，但每個人心裡都要有一套解決問題的方法，然後來互吵誰的做法比較好。e.g. 物件導向的切分顆粒度。

這時候你有沒有實務經驗、mental sense、協調能力、系統的通盤了解就很重要了。

當然，我相信寫程式超過一定年資的人一定有遇過找了三天三夜還找不出來的 bug，其實出在某一行隨手複製來的程式碼裡面。未來在專案漸趨龐大、token 消耗成本成為老闆關注焦點時，你就不可能什麼都讓 AI 幫你做。

那些一眼能看出問題出在哪個部件、有哪些可能發生問題地方的老鳥，就會越來越值錢（本來就很值錢）。先假設所有人都能夠解決這個問題，老鳥花的 token 就是比菜鳥少一個維度。

那問題就在於我們怎麼讓 AI 快速幫助我們成為老鳥，而不是聚焦在怎麼讓 AI 幫我們寫出一個國小生就 prompt 得出來的 implementation。